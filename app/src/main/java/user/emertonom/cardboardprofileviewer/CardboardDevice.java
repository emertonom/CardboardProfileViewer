package user.emertonom.cardboardprofileviewer;// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: user.emertonom.cardboardprofileviewer.CardboardDevice.proto

public final class CardboardDevice {
  private CardboardDevice() {}
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistry registry) {
  }
  public interface DeviceParamsOrBuilder extends
      // @@protoc_insertion_point(interface_extends:DeviceParams)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>optional string vendor = 1;</code>
     *
     * <pre>
     * String identifying the device's vendor (e.g. "Google, Inc.").
     * A device's [vendor, model] pair is expected to be globally unique.
     * </pre>
     */
    boolean hasVendor();
    /**
     * <code>optional string vendor = 1;</code>
     *
     * <pre>
     * String identifying the device's vendor (e.g. "Google, Inc.").
     * A device's [vendor, model] pair is expected to be globally unique.
     * </pre>
     */
    java.lang.String getVendor();
    /**
     * <code>optional string vendor = 1;</code>
     *
     * <pre>
     * String identifying the device's vendor (e.g. "Google, Inc.").
     * A device's [vendor, model] pair is expected to be globally unique.
     * </pre>
     */
    com.google.protobuf.ByteString
        getVendorBytes();

    /**
     * <code>optional string model = 2;</code>
     *
     * <pre>
     * String identifying the device's model, including revision info if
     * needed (e.g. "Cardboard v1").  A device's [vendor, model] pair is
     * expected to be globally unique.
     * </pre>
     */
    boolean hasModel();
    /**
     * <code>optional string model = 2;</code>
     *
     * <pre>
     * String identifying the device's model, including revision info if
     * needed (e.g. "Cardboard v1").  A device's [vendor, model] pair is
     * expected to be globally unique.
     * </pre>
     */
    java.lang.String getModel();
    /**
     * <code>optional string model = 2;</code>
     *
     * <pre>
     * String identifying the device's model, including revision info if
     * needed (e.g. "Cardboard v1").  A device's [vendor, model] pair is
     * expected to be globally unique.
     * </pre>
     */
    com.google.protobuf.ByteString
        getModelBytes();

    /**
     * <code>optional float screen_to_lens_distance = 3;</code>
     *
     * <pre>
     * Distance from the display screen to the optical center of lenses.
     * </pre>
     */
    boolean hasScreenToLensDistance();
    /**
     * <code>optional float screen_to_lens_distance = 3;</code>
     *
     * <pre>
     * Distance from the display screen to the optical center of lenses.
     * </pre>
     */
    float getScreenToLensDistance();

    /**
     * <code>optional float inter_lens_distance = 4;</code>
     *
     * <pre>
     * Horizontal distance between optical center of the lenses.
     * </pre>
     */
    boolean hasInterLensDistance();
    /**
     * <code>optional float inter_lens_distance = 4;</code>
     *
     * <pre>
     * Horizontal distance between optical center of the lenses.
     * </pre>
     */
    float getInterLensDistance();

    /**
     * <code>repeated float left_eye_field_of_view_angles = 5 [packed = true];</code>
     *
     * <pre>
     * Four-element tuple (left, right, bottom, top) of left eye's view extent
     * angles relative to center, assuming the following:
     *     * eye is aligned with optical center of lens
     *     * display screen is equal or larger than extents viewable through lens
     *     * nominal eye-to-lens distance
     *     * mirrored field of view will be applied to the right eye
     * These values are essentially used as an optimization to avoid rendering
     * pixels which can't be seen.
     * </pre>
     */
    java.util.List<java.lang.Float> getLeftEyeFieldOfViewAnglesList();
    /**
     * <code>repeated float left_eye_field_of_view_angles = 5 [packed = true];</code>
     *
     * <pre>
     * Four-element tuple (left, right, bottom, top) of left eye's view extent
     * angles relative to center, assuming the following:
     *     * eye is aligned with optical center of lens
     *     * display screen is equal or larger than extents viewable through lens
     *     * nominal eye-to-lens distance
     *     * mirrored field of view will be applied to the right eye
     * These values are essentially used as an optimization to avoid rendering
     * pixels which can't be seen.
     * </pre>
     */
    int getLeftEyeFieldOfViewAnglesCount();
    /**
     * <code>repeated float left_eye_field_of_view_angles = 5 [packed = true];</code>
     *
     * <pre>
     * Four-element tuple (left, right, bottom, top) of left eye's view extent
     * angles relative to center, assuming the following:
     *     * eye is aligned with optical center of lens
     *     * display screen is equal or larger than extents viewable through lens
     *     * nominal eye-to-lens distance
     *     * mirrored field of view will be applied to the right eye
     * These values are essentially used as an optimization to avoid rendering
     * pixels which can't be seen.
     * </pre>
     */
    float getLeftEyeFieldOfViewAngles(int index);

    /**
     * <code>optional .DeviceParams.VerticalAlignmentType vertical_alignment = 11 [default = BOTTOM];</code>
     *
     * <pre>
     * Set according to vertical alignment strategy-- see enum comments above.
     * NOTE: If you set this to CENTER, see special instructions for the
     * tray_to_lens_distance field below.
     * </pre>
     */
    boolean hasVerticalAlignment();
    /**
     * <code>optional .DeviceParams.VerticalAlignmentType vertical_alignment = 11 [default = BOTTOM];</code>
     *
     * <pre>
     * Set according to vertical alignment strategy-- see enum comments above.
     * NOTE: If you set this to CENTER, see special instructions for the
     * tray_to_lens_distance field below.
     * </pre>
     */
    CardboardDevice.DeviceParams.VerticalAlignmentType getVerticalAlignment();

    /**
     * <code>optional float tray_to_lens_distance = 6;</code>
     *
     * <pre>
     * If the phone is aligned vertically within the device by resting against
     * a fixed top or bottom tray, this is the distance from the tray to
     * optical center of the lenses.
     * NOTE: Due to a bug in initial versions of the SDK's, this field
     * must be set explicitly to .035 when vertical_alignment = CENTER.
     * </pre>
     */
    boolean hasTrayToLensDistance();
    /**
     * <code>optional float tray_to_lens_distance = 6;</code>
     *
     * <pre>
     * If the phone is aligned vertically within the device by resting against
     * a fixed top or bottom tray, this is the distance from the tray to
     * optical center of the lenses.
     * NOTE: Due to a bug in initial versions of the SDK's, this field
     * must be set explicitly to .035 when vertical_alignment = CENTER.
     * </pre>
     */
    float getTrayToLensDistance();

    /**
     * <code>repeated float distortion_coefficients = 7 [packed = true];</code>
     *
     * <pre>
     * Coefficients Ki for pincushion distortion function which maps
     * from position on real screen to virtual screen (i.e. texture) relative
     * to optical center:
     *    p' = p (1 + K1 r^2 + K2 r^4 + ... + Kn r^(2n))
     * where r is the distance in tan-angle units from the optical center,
     * p the input point, and p' the output point.  Tan-angle units can be
     * computed as distance on the screen divided by distance from the
     * virtual eye to the screen.
     * </pre>
     */
    java.util.List<java.lang.Float> getDistortionCoefficientsList();
    /**
     * <code>repeated float distortion_coefficients = 7 [packed = true];</code>
     *
     * <pre>
     * Coefficients Ki for pincushion distortion function which maps
     * from position on real screen to virtual screen (i.e. texture) relative
     * to optical center:
     *    p' = p (1 + K1 r^2 + K2 r^4 + ... + Kn r^(2n))
     * where r is the distance in tan-angle units from the optical center,
     * p the input point, and p' the output point.  Tan-angle units can be
     * computed as distance on the screen divided by distance from the
     * virtual eye to the screen.
     * </pre>
     */
    int getDistortionCoefficientsCount();
    /**
     * <code>repeated float distortion_coefficients = 7 [packed = true];</code>
     *
     * <pre>
     * Coefficients Ki for pincushion distortion function which maps
     * from position on real screen to virtual screen (i.e. texture) relative
     * to optical center:
     *    p' = p (1 + K1 r^2 + K2 r^4 + ... + Kn r^(2n))
     * where r is the distance in tan-angle units from the optical center,
     * p the input point, and p' the output point.  Tan-angle units can be
     * computed as distance on the screen divided by distance from the
     * virtual eye to the screen.
     * </pre>
     */
    float getDistortionCoefficients(int index);

    /**
     * <code>optional bool has_magnet = 10;</code>
     *
     * <pre>
     * Optionally, whether the head mount uses a magnet in any part of its
     * design.  Intended as hint as to whether phone's magnetometer is
     * available for tasks such as orientation tracking.
     * </pre>
     */
    boolean hasHasMagnet();
    /**
     * <code>optional bool has_magnet = 10;</code>
     *
     * <pre>
     * Optionally, whether the head mount uses a magnet in any part of its
     * design.  Intended as hint as to whether phone's magnetometer is
     * available for tasks such as orientation tracking.
     * </pre>
     */
    boolean getHasMagnet();

    /**
     * <code>optional .DeviceParams.ButtonType primary_button = 12 [default = MAGNET];</code>
     *
     * <pre>
     * Specify primary input mechanism of the HMD.  Intended for advisory
     * purposes only, to address simple questions such as "can HMD
     * be used with apps requiring a physical button event?" or "what icon
     * should be used to represent button action to the user?".
     * </pre>
     */
    boolean hasPrimaryButton();
    /**
     * <code>optional .DeviceParams.ButtonType primary_button = 12 [default = MAGNET];</code>
     *
     * <pre>
     * Specify primary input mechanism of the HMD.  Intended for advisory
     * purposes only, to address simple questions such as "can HMD
     * be used with apps requiring a physical button event?" or "what icon
     * should be used to represent button action to the user?".
     * </pre>
     */
    CardboardDevice.DeviceParams.ButtonType getPrimaryButton();
  }
  /**
   * Protobuf type {@code DeviceParams}
   */
  public  static final class DeviceParams extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:DeviceParams)
      DeviceParamsOrBuilder {
    // Use DeviceParams.newBuilder() to construct.
    private DeviceParams(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private DeviceParams() {
      vendor_ = "";
      model_ = "";
      screenToLensDistance_ = 0F;
      interLensDistance_ = 0F;
      leftEyeFieldOfViewAngles_ = java.util.Collections.emptyList();
      verticalAlignment_ = 0;
      trayToLensDistance_ = 0F;
      distortionCoefficients_ = java.util.Collections.emptyList();
      hasMagnet_ = false;
      primaryButton_ = 1;
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private DeviceParams(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry) {
      this();
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownField(input, unknownFields,
                                     extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 10: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000001;
              vendor_ = bs;
              break;
            }
            case 18: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000002;
              model_ = bs;
              break;
            }
            case 29: {
              bitField0_ |= 0x00000004;
              screenToLensDistance_ = input.readFloat();
              break;
            }
            case 37: {
              bitField0_ |= 0x00000008;
              interLensDistance_ = input.readFloat();
              break;
            }
            case 45: {
              if (!((mutable_bitField0_ & 0x00000010) == 0x00000010)) {
                leftEyeFieldOfViewAngles_ = new java.util.ArrayList<java.lang.Float>();
                mutable_bitField0_ |= 0x00000010;
              }
              leftEyeFieldOfViewAngles_.add(input.readFloat());
              break;
            }
            case 42: {
              int length = input.readRawVarint32();
              int limit = input.pushLimit(length);
              if (!((mutable_bitField0_ & 0x00000010) == 0x00000010) && input.getBytesUntilLimit() > 0) {
                leftEyeFieldOfViewAngles_ = new java.util.ArrayList<java.lang.Float>();
                mutable_bitField0_ |= 0x00000010;
              }
              while (input.getBytesUntilLimit() > 0) {
                leftEyeFieldOfViewAngles_.add(input.readFloat());
              }
              input.popLimit(limit);
              break;
            }
            case 53: {
              bitField0_ |= 0x00000020;
              trayToLensDistance_ = input.readFloat();
              break;
            }
            case 61: {
              if (!((mutable_bitField0_ & 0x00000080) == 0x00000080)) {
                distortionCoefficients_ = new java.util.ArrayList<java.lang.Float>();
                mutable_bitField0_ |= 0x00000080;
              }
              distortionCoefficients_.add(input.readFloat());
              break;
            }
            case 58: {
              int length = input.readRawVarint32();
              int limit = input.pushLimit(length);
              if (!((mutable_bitField0_ & 0x00000080) == 0x00000080) && input.getBytesUntilLimit() > 0) {
                distortionCoefficients_ = new java.util.ArrayList<java.lang.Float>();
                mutable_bitField0_ |= 0x00000080;
              }
              while (input.getBytesUntilLimit() > 0) {
                distortionCoefficients_.add(input.readFloat());
              }
              input.popLimit(limit);
              break;
            }
            case 80: {
              bitField0_ |= 0x00000040;
              hasMagnet_ = input.readBool();
              break;
            }
            case 88: {
              int rawValue = input.readEnum();
              CardboardDevice.DeviceParams.VerticalAlignmentType value = CardboardDevice.DeviceParams.VerticalAlignmentType.valueOf(rawValue);
              if (value == null) {
                unknownFields.mergeVarintField(11, rawValue);
              } else {
                bitField0_ |= 0x00000010;
                verticalAlignment_ = rawValue;
              }
              break;
            }
            case 96: {
              int rawValue = input.readEnum();
              CardboardDevice.DeviceParams.ButtonType value = CardboardDevice.DeviceParams.ButtonType.valueOf(rawValue);
              if (value == null) {
                unknownFields.mergeVarintField(12, rawValue);
              } else {
                bitField0_ |= 0x00000080;
                primaryButton_ = rawValue;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw new RuntimeException(e.setUnfinishedMessage(this));
      } catch (java.io.IOException e) {
        throw new RuntimeException(
            new com.google.protobuf.InvalidProtocolBufferException(
                e.getMessage()).setUnfinishedMessage(this));
      } finally {
        if (((mutable_bitField0_ & 0x00000010) == 0x00000010)) {
          leftEyeFieldOfViewAngles_ = java.util.Collections.unmodifiableList(leftEyeFieldOfViewAngles_);
        }
        if (((mutable_bitField0_ & 0x00000080) == 0x00000080)) {
          distortionCoefficients_ = java.util.Collections.unmodifiableList(distortionCoefficients_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return CardboardDevice.internal_static_DeviceParams_descriptor;
    }

    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return CardboardDevice.internal_static_DeviceParams_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              CardboardDevice.DeviceParams.class, CardboardDevice.DeviceParams.Builder.class);
    }

    /**
     * Protobuf enum {@code DeviceParams.VerticalAlignmentType}
     */
    public enum VerticalAlignmentType
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <code>BOTTOM = 0;</code>
       *
       * <pre>
       * phone rests against a fixed bottom tray
       * </pre>
       */
      BOTTOM(0, 0),
      /**
       * <code>CENTER = 1;</code>
       *
       * <pre>
       * phone screen assumed to be centered w.r.t. lenses
       * </pre>
       */
      CENTER(1, 1),
      /**
       * <code>TOP = 2;</code>
       *
       * <pre>
       * phone rests against a fixed top tray
       * </pre>
       */
      TOP(2, 2),
      ;

      /**
       * <code>BOTTOM = 0;</code>
       *
       * <pre>
       * phone rests against a fixed bottom tray
       * </pre>
       */
      public static final int BOTTOM_VALUE = 0;
      /**
       * <code>CENTER = 1;</code>
       *
       * <pre>
       * phone screen assumed to be centered w.r.t. lenses
       * </pre>
       */
      public static final int CENTER_VALUE = 1;
      /**
       * <code>TOP = 2;</code>
       *
       * <pre>
       * phone rests against a fixed top tray
       * </pre>
       */
      public static final int TOP_VALUE = 2;


      public final int getNumber() {
        return value;
      }

      public static VerticalAlignmentType valueOf(int value) {
        switch (value) {
          case 0: return BOTTOM;
          case 1: return CENTER;
          case 2: return TOP;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<VerticalAlignmentType>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          VerticalAlignmentType> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<VerticalAlignmentType>() {
              public VerticalAlignmentType findValueByNumber(int number) {
                return VerticalAlignmentType.valueOf(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        return getDescriptor().getValues().get(index);
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return CardboardDevice.DeviceParams.getDescriptor().getEnumTypes().get(0);
      }

      private static final VerticalAlignmentType[] VALUES = values();

      public static VerticalAlignmentType valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        return VALUES[desc.getIndex()];
      }

      private final int index;
      private final int value;

      private VerticalAlignmentType(int index, int value) {
        this.index = index;
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:DeviceParams.VerticalAlignmentType)
    }

    /**
     * Protobuf enum {@code DeviceParams.ButtonType}
     */
    public enum ButtonType
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <code>NONE = 0;</code>
       *
       * <pre>
       * No physical button, and touch screen is not easily accessible.
       * </pre>
       */
      NONE(0, 0),
      /**
       * <code>MAGNET = 1;</code>
       *
       * <pre>
       * HMD has integrated magnet switch similar to original Cardboard.
       * </pre>
       */
      MAGNET(1, 1),
      /**
       * <code>TOUCH = 2;</code>
       *
       * <pre>
       * At least a portion of touch screen is easily accessible to user for taps.
       * </pre>
       */
      TOUCH(2, 2),
      /**
       * <code>INDIRECT_TOUCH = 3;</code>
       *
       * <pre>
       * Touch screen is triggered indirectly via integrated button on the HMD.
       * </pre>
       */
      INDIRECT_TOUCH(3, 3),
      ;

      /**
       * <code>NONE = 0;</code>
       *
       * <pre>
       * No physical button, and touch screen is not easily accessible.
       * </pre>
       */
      public static final int NONE_VALUE = 0;
      /**
       * <code>MAGNET = 1;</code>
       *
       * <pre>
       * HMD has integrated magnet switch similar to original Cardboard.
       * </pre>
       */
      public static final int MAGNET_VALUE = 1;
      /**
       * <code>TOUCH = 2;</code>
       *
       * <pre>
       * At least a portion of touch screen is easily accessible to user for taps.
       * </pre>
       */
      public static final int TOUCH_VALUE = 2;
      /**
       * <code>INDIRECT_TOUCH = 3;</code>
       *
       * <pre>
       * Touch screen is triggered indirectly via integrated button on the HMD.
       * </pre>
       */
      public static final int INDIRECT_TOUCH_VALUE = 3;


      public final int getNumber() {
        return value;
      }

      public static ButtonType valueOf(int value) {
        switch (value) {
          case 0: return NONE;
          case 1: return MAGNET;
          case 2: return TOUCH;
          case 3: return INDIRECT_TOUCH;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<ButtonType>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          ButtonType> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<ButtonType>() {
              public ButtonType findValueByNumber(int number) {
                return ButtonType.valueOf(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        return getDescriptor().getValues().get(index);
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return CardboardDevice.DeviceParams.getDescriptor().getEnumTypes().get(1);
      }

      private static final ButtonType[] VALUES = values();

      public static ButtonType valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        return VALUES[desc.getIndex()];
      }

      private final int index;
      private final int value;

      private ButtonType(int index, int value) {
        this.index = index;
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:DeviceParams.ButtonType)
    }

    private int bitField0_;
    public static final int VENDOR_FIELD_NUMBER = 1;
    private volatile java.lang.Object vendor_;
    /**
     * <code>optional string vendor = 1;</code>
     *
     * <pre>
     * String identifying the device's vendor (e.g. "Google, Inc.").
     * A device's [vendor, model] pair is expected to be globally unique.
     * </pre>
     */
    public boolean hasVendor() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <code>optional string vendor = 1;</code>
     *
     * <pre>
     * String identifying the device's vendor (e.g. "Google, Inc.").
     * A device's [vendor, model] pair is expected to be globally unique.
     * </pre>
     */
    public java.lang.String getVendor() {
      java.lang.Object ref = vendor_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          vendor_ = s;
        }
        return s;
      }
    }
    /**
     * <code>optional string vendor = 1;</code>
     *
     * <pre>
     * String identifying the device's vendor (e.g. "Google, Inc.").
     * A device's [vendor, model] pair is expected to be globally unique.
     * </pre>
     */
    public com.google.protobuf.ByteString
        getVendorBytes() {
      java.lang.Object ref = vendor_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        vendor_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int MODEL_FIELD_NUMBER = 2;
    private volatile java.lang.Object model_;
    /**
     * <code>optional string model = 2;</code>
     *
     * <pre>
     * String identifying the device's model, including revision info if
     * needed (e.g. "Cardboard v1").  A device's [vendor, model] pair is
     * expected to be globally unique.
     * </pre>
     */
    public boolean hasModel() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <code>optional string model = 2;</code>
     *
     * <pre>
     * String identifying the device's model, including revision info if
     * needed (e.g. "Cardboard v1").  A device's [vendor, model] pair is
     * expected to be globally unique.
     * </pre>
     */
    public java.lang.String getModel() {
      java.lang.Object ref = model_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          model_ = s;
        }
        return s;
      }
    }
    /**
     * <code>optional string model = 2;</code>
     *
     * <pre>
     * String identifying the device's model, including revision info if
     * needed (e.g. "Cardboard v1").  A device's [vendor, model] pair is
     * expected to be globally unique.
     * </pre>
     */
    public com.google.protobuf.ByteString
        getModelBytes() {
      java.lang.Object ref = model_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        model_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int SCREEN_TO_LENS_DISTANCE_FIELD_NUMBER = 3;
    private float screenToLensDistance_;
    /**
     * <code>optional float screen_to_lens_distance = 3;</code>
     *
     * <pre>
     * Distance from the display screen to the optical center of lenses.
     * </pre>
     */
    public boolean hasScreenToLensDistance() {
      return ((bitField0_ & 0x00000004) == 0x00000004);
    }
    /**
     * <code>optional float screen_to_lens_distance = 3;</code>
     *
     * <pre>
     * Distance from the display screen to the optical center of lenses.
     * </pre>
     */
    public float getScreenToLensDistance() {
      return screenToLensDistance_;
    }

    public static final int INTER_LENS_DISTANCE_FIELD_NUMBER = 4;
    private float interLensDistance_;
    /**
     * <code>optional float inter_lens_distance = 4;</code>
     *
     * <pre>
     * Horizontal distance between optical center of the lenses.
     * </pre>
     */
    public boolean hasInterLensDistance() {
      return ((bitField0_ & 0x00000008) == 0x00000008);
    }
    /**
     * <code>optional float inter_lens_distance = 4;</code>
     *
     * <pre>
     * Horizontal distance between optical center of the lenses.
     * </pre>
     */
    public float getInterLensDistance() {
      return interLensDistance_;
    }

    public static final int LEFT_EYE_FIELD_OF_VIEW_ANGLES_FIELD_NUMBER = 5;
    private java.util.List<java.lang.Float> leftEyeFieldOfViewAngles_;
    /**
     * <code>repeated float left_eye_field_of_view_angles = 5 [packed = true];</code>
     *
     * <pre>
     * Four-element tuple (left, right, bottom, top) of left eye's view extent
     * angles relative to center, assuming the following:
     *     * eye is aligned with optical center of lens
     *     * display screen is equal or larger than extents viewable through lens
     *     * nominal eye-to-lens distance
     *     * mirrored field of view will be applied to the right eye
     * These values are essentially used as an optimization to avoid rendering
     * pixels which can't be seen.
     * </pre>
     */
    public java.util.List<java.lang.Float>
        getLeftEyeFieldOfViewAnglesList() {
      return leftEyeFieldOfViewAngles_;
    }
    /**
     * <code>repeated float left_eye_field_of_view_angles = 5 [packed = true];</code>
     *
     * <pre>
     * Four-element tuple (left, right, bottom, top) of left eye's view extent
     * angles relative to center, assuming the following:
     *     * eye is aligned with optical center of lens
     *     * display screen is equal or larger than extents viewable through lens
     *     * nominal eye-to-lens distance
     *     * mirrored field of view will be applied to the right eye
     * These values are essentially used as an optimization to avoid rendering
     * pixels which can't be seen.
     * </pre>
     */
    public int getLeftEyeFieldOfViewAnglesCount() {
      return leftEyeFieldOfViewAngles_.size();
    }
    /**
     * <code>repeated float left_eye_field_of_view_angles = 5 [packed = true];</code>
     *
     * <pre>
     * Four-element tuple (left, right, bottom, top) of left eye's view extent
     * angles relative to center, assuming the following:
     *     * eye is aligned with optical center of lens
     *     * display screen is equal or larger than extents viewable through lens
     *     * nominal eye-to-lens distance
     *     * mirrored field of view will be applied to the right eye
     * These values are essentially used as an optimization to avoid rendering
     * pixels which can't be seen.
     * </pre>
     */
    public float getLeftEyeFieldOfViewAngles(int index) {
      return leftEyeFieldOfViewAngles_.get(index);
    }
    private int leftEyeFieldOfViewAnglesMemoizedSerializedSize = -1;

    public static final int VERTICAL_ALIGNMENT_FIELD_NUMBER = 11;
    private int verticalAlignment_;
    /**
     * <code>optional .DeviceParams.VerticalAlignmentType vertical_alignment = 11 [default = BOTTOM];</code>
     *
     * <pre>
     * Set according to vertical alignment strategy-- see enum comments above.
     * NOTE: If you set this to CENTER, see special instructions for the
     * tray_to_lens_distance field below.
     * </pre>
     */
    public boolean hasVerticalAlignment() {
      return ((bitField0_ & 0x00000010) == 0x00000010);
    }
    /**
     * <code>optional .DeviceParams.VerticalAlignmentType vertical_alignment = 11 [default = BOTTOM];</code>
     *
     * <pre>
     * Set according to vertical alignment strategy-- see enum comments above.
     * NOTE: If you set this to CENTER, see special instructions for the
     * tray_to_lens_distance field below.
     * </pre>
     */
    public CardboardDevice.DeviceParams.VerticalAlignmentType getVerticalAlignment() {
      CardboardDevice.DeviceParams.VerticalAlignmentType result = CardboardDevice.DeviceParams.VerticalAlignmentType.valueOf(verticalAlignment_);
      return result == null ? CardboardDevice.DeviceParams.VerticalAlignmentType.BOTTOM : result;
    }

    public static final int TRAY_TO_LENS_DISTANCE_FIELD_NUMBER = 6;
    private float trayToLensDistance_;
    /**
     * <code>optional float tray_to_lens_distance = 6;</code>
     *
     * <pre>
     * If the phone is aligned vertically within the device by resting against
     * a fixed top or bottom tray, this is the distance from the tray to
     * optical center of the lenses.
     * NOTE: Due to a bug in initial versions of the SDK's, this field
     * must be set explicitly to .035 when vertical_alignment = CENTER.
     * </pre>
     */
    public boolean hasTrayToLensDistance() {
      return ((bitField0_ & 0x00000020) == 0x00000020);
    }
    /**
     * <code>optional float tray_to_lens_distance = 6;</code>
     *
     * <pre>
     * If the phone is aligned vertically within the device by resting against
     * a fixed top or bottom tray, this is the distance from the tray to
     * optical center of the lenses.
     * NOTE: Due to a bug in initial versions of the SDK's, this field
     * must be set explicitly to .035 when vertical_alignment = CENTER.
     * </pre>
     */
    public float getTrayToLensDistance() {
      return trayToLensDistance_;
    }

    public static final int DISTORTION_COEFFICIENTS_FIELD_NUMBER = 7;
    private java.util.List<java.lang.Float> distortionCoefficients_;
    /**
     * <code>repeated float distortion_coefficients = 7 [packed = true];</code>
     *
     * <pre>
     * Coefficients Ki for pincushion distortion function which maps
     * from position on real screen to virtual screen (i.e. texture) relative
     * to optical center:
     *    p' = p (1 + K1 r^2 + K2 r^4 + ... + Kn r^(2n))
     * where r is the distance in tan-angle units from the optical center,
     * p the input point, and p' the output point.  Tan-angle units can be
     * computed as distance on the screen divided by distance from the
     * virtual eye to the screen.
     * </pre>
     */
    public java.util.List<java.lang.Float>
        getDistortionCoefficientsList() {
      return distortionCoefficients_;
    }
    /**
     * <code>repeated float distortion_coefficients = 7 [packed = true];</code>
     *
     * <pre>
     * Coefficients Ki for pincushion distortion function which maps
     * from position on real screen to virtual screen (i.e. texture) relative
     * to optical center:
     *    p' = p (1 + K1 r^2 + K2 r^4 + ... + Kn r^(2n))
     * where r is the distance in tan-angle units from the optical center,
     * p the input point, and p' the output point.  Tan-angle units can be
     * computed as distance on the screen divided by distance from the
     * virtual eye to the screen.
     * </pre>
     */
    public int getDistortionCoefficientsCount() {
      return distortionCoefficients_.size();
    }
    /**
     * <code>repeated float distortion_coefficients = 7 [packed = true];</code>
     *
     * <pre>
     * Coefficients Ki for pincushion distortion function which maps
     * from position on real screen to virtual screen (i.e. texture) relative
     * to optical center:
     *    p' = p (1 + K1 r^2 + K2 r^4 + ... + Kn r^(2n))
     * where r is the distance in tan-angle units from the optical center,
     * p the input point, and p' the output point.  Tan-angle units can be
     * computed as distance on the screen divided by distance from the
     * virtual eye to the screen.
     * </pre>
     */
    public float getDistortionCoefficients(int index) {
      return distortionCoefficients_.get(index);
    }
    private int distortionCoefficientsMemoizedSerializedSize = -1;

    public static final int HAS_MAGNET_FIELD_NUMBER = 10;
    private boolean hasMagnet_;
    /**
     * <code>optional bool has_magnet = 10;</code>
     *
     * <pre>
     * Optionally, whether the head mount uses a magnet in any part of its
     * design.  Intended as hint as to whether phone's magnetometer is
     * available for tasks such as orientation tracking.
     * </pre>
     */
    public boolean hasHasMagnet() {
      return ((bitField0_ & 0x00000040) == 0x00000040);
    }
    /**
     * <code>optional bool has_magnet = 10;</code>
     *
     * <pre>
     * Optionally, whether the head mount uses a magnet in any part of its
     * design.  Intended as hint as to whether phone's magnetometer is
     * available for tasks such as orientation tracking.
     * </pre>
     */
    public boolean getHasMagnet() {
      return hasMagnet_;
    }

    public static final int PRIMARY_BUTTON_FIELD_NUMBER = 12;
    private int primaryButton_;
    /**
     * <code>optional .DeviceParams.ButtonType primary_button = 12 [default = MAGNET];</code>
     *
     * <pre>
     * Specify primary input mechanism of the HMD.  Intended for advisory
     * purposes only, to address simple questions such as "can HMD
     * be used with apps requiring a physical button event?" or "what icon
     * should be used to represent button action to the user?".
     * </pre>
     */
    public boolean hasPrimaryButton() {
      return ((bitField0_ & 0x00000080) == 0x00000080);
    }
    /**
     * <code>optional .DeviceParams.ButtonType primary_button = 12 [default = MAGNET];</code>
     *
     * <pre>
     * Specify primary input mechanism of the HMD.  Intended for advisory
     * purposes only, to address simple questions such as "can HMD
     * be used with apps requiring a physical button event?" or "what icon
     * should be used to represent button action to the user?".
     * </pre>
     */
    public CardboardDevice.DeviceParams.ButtonType getPrimaryButton() {
      CardboardDevice.DeviceParams.ButtonType result = CardboardDevice.DeviceParams.ButtonType.valueOf(primaryButton_);
      return result == null ? CardboardDevice.DeviceParams.ButtonType.MAGNET : result;
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      getSerializedSize();
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 1, vendor_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 2, model_);
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        output.writeFloat(3, screenToLensDistance_);
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        output.writeFloat(4, interLensDistance_);
      }
      if (getLeftEyeFieldOfViewAnglesList().size() > 0) {
        output.writeRawVarint32(42);
        output.writeRawVarint32(leftEyeFieldOfViewAnglesMemoizedSerializedSize);
      }
      for (int i = 0; i < leftEyeFieldOfViewAngles_.size(); i++) {
        output.writeFloatNoTag(leftEyeFieldOfViewAngles_.get(i));
      }
      if (((bitField0_ & 0x00000020) == 0x00000020)) {
        output.writeFloat(6, trayToLensDistance_);
      }
      if (getDistortionCoefficientsList().size() > 0) {
        output.writeRawVarint32(58);
        output.writeRawVarint32(distortionCoefficientsMemoizedSerializedSize);
      }
      for (int i = 0; i < distortionCoefficients_.size(); i++) {
        output.writeFloatNoTag(distortionCoefficients_.get(i));
      }
      if (((bitField0_ & 0x00000040) == 0x00000040)) {
        output.writeBool(10, hasMagnet_);
      }
      if (((bitField0_ & 0x00000010) == 0x00000010)) {
        output.writeEnum(11, verticalAlignment_);
      }
      if (((bitField0_ & 0x00000080) == 0x00000080)) {
        output.writeEnum(12, primaryButton_);
      }
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(1, vendor_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(2, model_);
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.CodedOutputStream
          .computeFloatSize(3, screenToLensDistance_);
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        size += com.google.protobuf.CodedOutputStream
          .computeFloatSize(4, interLensDistance_);
      }
      {
        int dataSize = 0;
        dataSize = 4 * getLeftEyeFieldOfViewAnglesList().size();
        size += dataSize;
        if (!getLeftEyeFieldOfViewAnglesList().isEmpty()) {
          size += 1;
          size += com.google.protobuf.CodedOutputStream
              .computeInt32SizeNoTag(dataSize);
        }
        leftEyeFieldOfViewAnglesMemoizedSerializedSize = dataSize;
      }
      if (((bitField0_ & 0x00000020) == 0x00000020)) {
        size += com.google.protobuf.CodedOutputStream
          .computeFloatSize(6, trayToLensDistance_);
      }
      {
        int dataSize = 0;
        dataSize = 4 * getDistortionCoefficientsList().size();
        size += dataSize;
        if (!getDistortionCoefficientsList().isEmpty()) {
          size += 1;
          size += com.google.protobuf.CodedOutputStream
              .computeInt32SizeNoTag(dataSize);
        }
        distortionCoefficientsMemoizedSerializedSize = dataSize;
      }
      if (((bitField0_ & 0x00000040) == 0x00000040)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(10, hasMagnet_);
      }
      if (((bitField0_ & 0x00000010) == 0x00000010)) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(11, verticalAlignment_);
      }
      if (((bitField0_ & 0x00000080) == 0x00000080)) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(12, primaryButton_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    private static final long serialVersionUID = 0L;
    public static CardboardDevice.DeviceParams parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static CardboardDevice.DeviceParams parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static CardboardDevice.DeviceParams parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static CardboardDevice.DeviceParams parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static CardboardDevice.DeviceParams parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return PARSER.parseFrom(input);
    }
    public static CardboardDevice.DeviceParams parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return PARSER.parseFrom(input, extensionRegistry);
    }
    public static CardboardDevice.DeviceParams parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return PARSER.parseDelimitedFrom(input);
    }
    public static CardboardDevice.DeviceParams parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return PARSER.parseDelimitedFrom(input, extensionRegistry);
    }
    public static CardboardDevice.DeviceParams parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return PARSER.parseFrom(input);
    }
    public static CardboardDevice.DeviceParams parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return PARSER.parseFrom(input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(CardboardDevice.DeviceParams prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code DeviceParams}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:DeviceParams)
        CardboardDevice.DeviceParamsOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return CardboardDevice.internal_static_DeviceParams_descriptor;
      }

      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return CardboardDevice.internal_static_DeviceParams_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                CardboardDevice.DeviceParams.class, CardboardDevice.DeviceParams.Builder.class);
      }

      // Construct using user.emertonom.cardboardprofileviewer.CardboardDevice.DeviceParams.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders) {
        }
      }
      public Builder clear() {
        super.clear();
        vendor_ = "";
        bitField0_ = (bitField0_ & ~0x00000001);
        model_ = "";
        bitField0_ = (bitField0_ & ~0x00000002);
        screenToLensDistance_ = 0F;
        bitField0_ = (bitField0_ & ~0x00000004);
        interLensDistance_ = 0F;
        bitField0_ = (bitField0_ & ~0x00000008);
        leftEyeFieldOfViewAngles_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000010);
        verticalAlignment_ = 0;
        bitField0_ = (bitField0_ & ~0x00000020);
        trayToLensDistance_ = 0F;
        bitField0_ = (bitField0_ & ~0x00000040);
        distortionCoefficients_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000080);
        hasMagnet_ = false;
        bitField0_ = (bitField0_ & ~0x00000100);
        primaryButton_ = 1;
        bitField0_ = (bitField0_ & ~0x00000200);
        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return CardboardDevice.internal_static_DeviceParams_descriptor;
      }

      public CardboardDevice.DeviceParams getDefaultInstanceForType() {
        return CardboardDevice.DeviceParams.getDefaultInstance();
      }

      public CardboardDevice.DeviceParams build() {
        CardboardDevice.DeviceParams result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public CardboardDevice.DeviceParams buildPartial() {
        CardboardDevice.DeviceParams result = new CardboardDevice.DeviceParams(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        result.vendor_ = vendor_;
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        result.model_ = model_;
        if (((from_bitField0_ & 0x00000004) == 0x00000004)) {
          to_bitField0_ |= 0x00000004;
        }
        result.screenToLensDistance_ = screenToLensDistance_;
        if (((from_bitField0_ & 0x00000008) == 0x00000008)) {
          to_bitField0_ |= 0x00000008;
        }
        result.interLensDistance_ = interLensDistance_;
        if (((bitField0_ & 0x00000010) == 0x00000010)) {
          leftEyeFieldOfViewAngles_ = java.util.Collections.unmodifiableList(leftEyeFieldOfViewAngles_);
          bitField0_ = (bitField0_ & ~0x00000010);
        }
        result.leftEyeFieldOfViewAngles_ = leftEyeFieldOfViewAngles_;
        if (((from_bitField0_ & 0x00000020) == 0x00000020)) {
          to_bitField0_ |= 0x00000010;
        }
        result.verticalAlignment_ = verticalAlignment_;
        if (((from_bitField0_ & 0x00000040) == 0x00000040)) {
          to_bitField0_ |= 0x00000020;
        }
        result.trayToLensDistance_ = trayToLensDistance_;
        if (((bitField0_ & 0x00000080) == 0x00000080)) {
          distortionCoefficients_ = java.util.Collections.unmodifiableList(distortionCoefficients_);
          bitField0_ = (bitField0_ & ~0x00000080);
        }
        result.distortionCoefficients_ = distortionCoefficients_;
        if (((from_bitField0_ & 0x00000100) == 0x00000100)) {
          to_bitField0_ |= 0x00000040;
        }
        result.hasMagnet_ = hasMagnet_;
        if (((from_bitField0_ & 0x00000200) == 0x00000200)) {
          to_bitField0_ |= 0x00000080;
        }
        result.primaryButton_ = primaryButton_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof CardboardDevice.DeviceParams) {
          return mergeFrom((CardboardDevice.DeviceParams)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(CardboardDevice.DeviceParams other) {
        if (other == CardboardDevice.DeviceParams.getDefaultInstance()) return this;
        if (other.hasVendor()) {
          bitField0_ |= 0x00000001;
          vendor_ = other.vendor_;
          onChanged();
        }
        if (other.hasModel()) {
          bitField0_ |= 0x00000002;
          model_ = other.model_;
          onChanged();
        }
        if (other.hasScreenToLensDistance()) {
          setScreenToLensDistance(other.getScreenToLensDistance());
        }
        if (other.hasInterLensDistance()) {
          setInterLensDistance(other.getInterLensDistance());
        }
        if (!other.leftEyeFieldOfViewAngles_.isEmpty()) {
          if (leftEyeFieldOfViewAngles_.isEmpty()) {
            leftEyeFieldOfViewAngles_ = other.leftEyeFieldOfViewAngles_;
            bitField0_ = (bitField0_ & ~0x00000010);
          } else {
            ensureLeftEyeFieldOfViewAnglesIsMutable();
            leftEyeFieldOfViewAngles_.addAll(other.leftEyeFieldOfViewAngles_);
          }
          onChanged();
        }
        if (other.hasVerticalAlignment()) {
          setVerticalAlignment(other.getVerticalAlignment());
        }
        if (other.hasTrayToLensDistance()) {
          setTrayToLensDistance(other.getTrayToLensDistance());
        }
        if (!other.distortionCoefficients_.isEmpty()) {
          if (distortionCoefficients_.isEmpty()) {
            distortionCoefficients_ = other.distortionCoefficients_;
            bitField0_ = (bitField0_ & ~0x00000080);
          } else {
            ensureDistortionCoefficientsIsMutable();
            distortionCoefficients_.addAll(other.distortionCoefficients_);
          }
          onChanged();
        }
        if (other.hasHasMagnet()) {
          setHasMagnet(other.getHasMagnet());
        }
        if (other.hasPrimaryButton()) {
          setPrimaryButton(other.getPrimaryButton());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        CardboardDevice.DeviceParams parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (CardboardDevice.DeviceParams) e.getUnfinishedMessage();
          throw e;
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.lang.Object vendor_ = "";
      /**
       * <code>optional string vendor = 1;</code>
       *
       * <pre>
       * String identifying the device's vendor (e.g. "Google, Inc.").
       * A device's [vendor, model] pair is expected to be globally unique.
       * </pre>
       */
      public boolean hasVendor() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <code>optional string vendor = 1;</code>
       *
       * <pre>
       * String identifying the device's vendor (e.g. "Google, Inc.").
       * A device's [vendor, model] pair is expected to be globally unique.
       * </pre>
       */
      public java.lang.String getVendor() {
        java.lang.Object ref = vendor_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            vendor_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <code>optional string vendor = 1;</code>
       *
       * <pre>
       * String identifying the device's vendor (e.g. "Google, Inc.").
       * A device's [vendor, model] pair is expected to be globally unique.
       * </pre>
       */
      public com.google.protobuf.ByteString
          getVendorBytes() {
        java.lang.Object ref = vendor_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          vendor_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>optional string vendor = 1;</code>
       *
       * <pre>
       * String identifying the device's vendor (e.g. "Google, Inc.").
       * A device's [vendor, model] pair is expected to be globally unique.
       * </pre>
       */
      public Builder setVendor(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        vendor_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional string vendor = 1;</code>
       *
       * <pre>
       * String identifying the device's vendor (e.g. "Google, Inc.").
       * A device's [vendor, model] pair is expected to be globally unique.
       * </pre>
       */
      public Builder clearVendor() {
        bitField0_ = (bitField0_ & ~0x00000001);
        vendor_ = getDefaultInstance().getVendor();
        onChanged();
        return this;
      }
      /**
       * <code>optional string vendor = 1;</code>
       *
       * <pre>
       * String identifying the device's vendor (e.g. "Google, Inc.").
       * A device's [vendor, model] pair is expected to be globally unique.
       * </pre>
       */
      public Builder setVendorBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        vendor_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object model_ = "";
      /**
       * <code>optional string model = 2;</code>
       *
       * <pre>
       * String identifying the device's model, including revision info if
       * needed (e.g. "Cardboard v1").  A device's [vendor, model] pair is
       * expected to be globally unique.
       * </pre>
       */
      public boolean hasModel() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       * <code>optional string model = 2;</code>
       *
       * <pre>
       * String identifying the device's model, including revision info if
       * needed (e.g. "Cardboard v1").  A device's [vendor, model] pair is
       * expected to be globally unique.
       * </pre>
       */
      public java.lang.String getModel() {
        java.lang.Object ref = model_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            model_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <code>optional string model = 2;</code>
       *
       * <pre>
       * String identifying the device's model, including revision info if
       * needed (e.g. "Cardboard v1").  A device's [vendor, model] pair is
       * expected to be globally unique.
       * </pre>
       */
      public com.google.protobuf.ByteString
          getModelBytes() {
        java.lang.Object ref = model_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          model_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>optional string model = 2;</code>
       *
       * <pre>
       * String identifying the device's model, including revision info if
       * needed (e.g. "Cardboard v1").  A device's [vendor, model] pair is
       * expected to be globally unique.
       * </pre>
       */
      public Builder setModel(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000002;
        model_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional string model = 2;</code>
       *
       * <pre>
       * String identifying the device's model, including revision info if
       * needed (e.g. "Cardboard v1").  A device's [vendor, model] pair is
       * expected to be globally unique.
       * </pre>
       */
      public Builder clearModel() {
        bitField0_ = (bitField0_ & ~0x00000002);
        model_ = getDefaultInstance().getModel();
        onChanged();
        return this;
      }
      /**
       * <code>optional string model = 2;</code>
       *
       * <pre>
       * String identifying the device's model, including revision info if
       * needed (e.g. "Cardboard v1").  A device's [vendor, model] pair is
       * expected to be globally unique.
       * </pre>
       */
      public Builder setModelBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000002;
        model_ = value;
        onChanged();
        return this;
      }

      private float screenToLensDistance_ ;
      /**
       * <code>optional float screen_to_lens_distance = 3;</code>
       *
       * <pre>
       * Distance from the display screen to the optical center of lenses.
       * </pre>
       */
      public boolean hasScreenToLensDistance() {
        return ((bitField0_ & 0x00000004) == 0x00000004);
      }
      /**
       * <code>optional float screen_to_lens_distance = 3;</code>
       *
       * <pre>
       * Distance from the display screen to the optical center of lenses.
       * </pre>
       */
      public float getScreenToLensDistance() {
        return screenToLensDistance_;
      }
      /**
       * <code>optional float screen_to_lens_distance = 3;</code>
       *
       * <pre>
       * Distance from the display screen to the optical center of lenses.
       * </pre>
       */
      public Builder setScreenToLensDistance(float value) {
        bitField0_ |= 0x00000004;
        screenToLensDistance_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional float screen_to_lens_distance = 3;</code>
       *
       * <pre>
       * Distance from the display screen to the optical center of lenses.
       * </pre>
       */
      public Builder clearScreenToLensDistance() {
        bitField0_ = (bitField0_ & ~0x00000004);
        screenToLensDistance_ = 0F;
        onChanged();
        return this;
      }

      private float interLensDistance_ ;
      /**
       * <code>optional float inter_lens_distance = 4;</code>
       *
       * <pre>
       * Horizontal distance between optical center of the lenses.
       * </pre>
       */
      public boolean hasInterLensDistance() {
        return ((bitField0_ & 0x00000008) == 0x00000008);
      }
      /**
       * <code>optional float inter_lens_distance = 4;</code>
       *
       * <pre>
       * Horizontal distance between optical center of the lenses.
       * </pre>
       */
      public float getInterLensDistance() {
        return interLensDistance_;
      }
      /**
       * <code>optional float inter_lens_distance = 4;</code>
       *
       * <pre>
       * Horizontal distance between optical center of the lenses.
       * </pre>
       */
      public Builder setInterLensDistance(float value) {
        bitField0_ |= 0x00000008;
        interLensDistance_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional float inter_lens_distance = 4;</code>
       *
       * <pre>
       * Horizontal distance between optical center of the lenses.
       * </pre>
       */
      public Builder clearInterLensDistance() {
        bitField0_ = (bitField0_ & ~0x00000008);
        interLensDistance_ = 0F;
        onChanged();
        return this;
      }

      private java.util.List<java.lang.Float> leftEyeFieldOfViewAngles_ = java.util.Collections.emptyList();
      private void ensureLeftEyeFieldOfViewAnglesIsMutable() {
        if (!((bitField0_ & 0x00000010) == 0x00000010)) {
          leftEyeFieldOfViewAngles_ = new java.util.ArrayList<java.lang.Float>(leftEyeFieldOfViewAngles_);
          bitField0_ |= 0x00000010;
         }
      }
      /**
       * <code>repeated float left_eye_field_of_view_angles = 5 [packed = true];</code>
       *
       * <pre>
       * Four-element tuple (left, right, bottom, top) of left eye's view extent
       * angles relative to center, assuming the following:
       *     * eye is aligned with optical center of lens
       *     * display screen is equal or larger than extents viewable through lens
       *     * nominal eye-to-lens distance
       *     * mirrored field of view will be applied to the right eye
       * These values are essentially used as an optimization to avoid rendering
       * pixels which can't be seen.
       * </pre>
       */
      public java.util.List<java.lang.Float>
          getLeftEyeFieldOfViewAnglesList() {
        return java.util.Collections.unmodifiableList(leftEyeFieldOfViewAngles_);
      }
      /**
       * <code>repeated float left_eye_field_of_view_angles = 5 [packed = true];</code>
       *
       * <pre>
       * Four-element tuple (left, right, bottom, top) of left eye's view extent
       * angles relative to center, assuming the following:
       *     * eye is aligned with optical center of lens
       *     * display screen is equal or larger than extents viewable through lens
       *     * nominal eye-to-lens distance
       *     * mirrored field of view will be applied to the right eye
       * These values are essentially used as an optimization to avoid rendering
       * pixels which can't be seen.
       * </pre>
       */
      public int getLeftEyeFieldOfViewAnglesCount() {
        return leftEyeFieldOfViewAngles_.size();
      }
      /**
       * <code>repeated float left_eye_field_of_view_angles = 5 [packed = true];</code>
       *
       * <pre>
       * Four-element tuple (left, right, bottom, top) of left eye's view extent
       * angles relative to center, assuming the following:
       *     * eye is aligned with optical center of lens
       *     * display screen is equal or larger than extents viewable through lens
       *     * nominal eye-to-lens distance
       *     * mirrored field of view will be applied to the right eye
       * These values are essentially used as an optimization to avoid rendering
       * pixels which can't be seen.
       * </pre>
       */
      public float getLeftEyeFieldOfViewAngles(int index) {
        return leftEyeFieldOfViewAngles_.get(index);
      }
      /**
       * <code>repeated float left_eye_field_of_view_angles = 5 [packed = true];</code>
       *
       * <pre>
       * Four-element tuple (left, right, bottom, top) of left eye's view extent
       * angles relative to center, assuming the following:
       *     * eye is aligned with optical center of lens
       *     * display screen is equal or larger than extents viewable through lens
       *     * nominal eye-to-lens distance
       *     * mirrored field of view will be applied to the right eye
       * These values are essentially used as an optimization to avoid rendering
       * pixels which can't be seen.
       * </pre>
       */
      public Builder setLeftEyeFieldOfViewAngles(
          int index, float value) {
        ensureLeftEyeFieldOfViewAnglesIsMutable();
        leftEyeFieldOfViewAngles_.set(index, value);
        onChanged();
        return this;
      }
      /**
       * <code>repeated float left_eye_field_of_view_angles = 5 [packed = true];</code>
       *
       * <pre>
       * Four-element tuple (left, right, bottom, top) of left eye's view extent
       * angles relative to center, assuming the following:
       *     * eye is aligned with optical center of lens
       *     * display screen is equal or larger than extents viewable through lens
       *     * nominal eye-to-lens distance
       *     * mirrored field of view will be applied to the right eye
       * These values are essentially used as an optimization to avoid rendering
       * pixels which can't be seen.
       * </pre>
       */
      public Builder addLeftEyeFieldOfViewAngles(float value) {
        ensureLeftEyeFieldOfViewAnglesIsMutable();
        leftEyeFieldOfViewAngles_.add(value);
        onChanged();
        return this;
      }
      /**
       * <code>repeated float left_eye_field_of_view_angles = 5 [packed = true];</code>
       *
       * <pre>
       * Four-element tuple (left, right, bottom, top) of left eye's view extent
       * angles relative to center, assuming the following:
       *     * eye is aligned with optical center of lens
       *     * display screen is equal or larger than extents viewable through lens
       *     * nominal eye-to-lens distance
       *     * mirrored field of view will be applied to the right eye
       * These values are essentially used as an optimization to avoid rendering
       * pixels which can't be seen.
       * </pre>
       */
      public Builder addAllLeftEyeFieldOfViewAngles(
          java.lang.Iterable<? extends java.lang.Float> values) {
        ensureLeftEyeFieldOfViewAnglesIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, leftEyeFieldOfViewAngles_);
        onChanged();
        return this;
      }
      /**
       * <code>repeated float left_eye_field_of_view_angles = 5 [packed = true];</code>
       *
       * <pre>
       * Four-element tuple (left, right, bottom, top) of left eye's view extent
       * angles relative to center, assuming the following:
       *     * eye is aligned with optical center of lens
       *     * display screen is equal or larger than extents viewable through lens
       *     * nominal eye-to-lens distance
       *     * mirrored field of view will be applied to the right eye
       * These values are essentially used as an optimization to avoid rendering
       * pixels which can't be seen.
       * </pre>
       */
      public Builder clearLeftEyeFieldOfViewAngles() {
        leftEyeFieldOfViewAngles_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000010);
        onChanged();
        return this;
      }

      private int verticalAlignment_ = 0;
      /**
       * <code>optional .DeviceParams.VerticalAlignmentType vertical_alignment = 11 [default = BOTTOM];</code>
       *
       * <pre>
       * Set according to vertical alignment strategy-- see enum comments above.
       * NOTE: If you set this to CENTER, see special instructions for the
       * tray_to_lens_distance field below.
       * </pre>
       */
      public boolean hasVerticalAlignment() {
        return ((bitField0_ & 0x00000020) == 0x00000020);
      }
      /**
       * <code>optional .DeviceParams.VerticalAlignmentType vertical_alignment = 11 [default = BOTTOM];</code>
       *
       * <pre>
       * Set according to vertical alignment strategy-- see enum comments above.
       * NOTE: If you set this to CENTER, see special instructions for the
       * tray_to_lens_distance field below.
       * </pre>
       */
      public CardboardDevice.DeviceParams.VerticalAlignmentType getVerticalAlignment() {
        CardboardDevice.DeviceParams.VerticalAlignmentType result = CardboardDevice.DeviceParams.VerticalAlignmentType.valueOf(verticalAlignment_);
        return result == null ? CardboardDevice.DeviceParams.VerticalAlignmentType.BOTTOM : result;
      }
      /**
       * <code>optional .DeviceParams.VerticalAlignmentType vertical_alignment = 11 [default = BOTTOM];</code>
       *
       * <pre>
       * Set according to vertical alignment strategy-- see enum comments above.
       * NOTE: If you set this to CENTER, see special instructions for the
       * tray_to_lens_distance field below.
       * </pre>
       */
      public Builder setVerticalAlignment(CardboardDevice.DeviceParams.VerticalAlignmentType value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000020;
        verticalAlignment_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <code>optional .DeviceParams.VerticalAlignmentType vertical_alignment = 11 [default = BOTTOM];</code>
       *
       * <pre>
       * Set according to vertical alignment strategy-- see enum comments above.
       * NOTE: If you set this to CENTER, see special instructions for the
       * tray_to_lens_distance field below.
       * </pre>
       */
      public Builder clearVerticalAlignment() {
        bitField0_ = (bitField0_ & ~0x00000020);
        verticalAlignment_ = 0;
        onChanged();
        return this;
      }

      private float trayToLensDistance_ ;
      /**
       * <code>optional float tray_to_lens_distance = 6;</code>
       *
       * <pre>
       * If the phone is aligned vertically within the device by resting against
       * a fixed top or bottom tray, this is the distance from the tray to
       * optical center of the lenses.
       * NOTE: Due to a bug in initial versions of the SDK's, this field
       * must be set explicitly to .035 when vertical_alignment = CENTER.
       * </pre>
       */
      public boolean hasTrayToLensDistance() {
        return ((bitField0_ & 0x00000040) == 0x00000040);
      }
      /**
       * <code>optional float tray_to_lens_distance = 6;</code>
       *
       * <pre>
       * If the phone is aligned vertically within the device by resting against
       * a fixed top or bottom tray, this is the distance from the tray to
       * optical center of the lenses.
       * NOTE: Due to a bug in initial versions of the SDK's, this field
       * must be set explicitly to .035 when vertical_alignment = CENTER.
       * </pre>
       */
      public float getTrayToLensDistance() {
        return trayToLensDistance_;
      }
      /**
       * <code>optional float tray_to_lens_distance = 6;</code>
       *
       * <pre>
       * If the phone is aligned vertically within the device by resting against
       * a fixed top or bottom tray, this is the distance from the tray to
       * optical center of the lenses.
       * NOTE: Due to a bug in initial versions of the SDK's, this field
       * must be set explicitly to .035 when vertical_alignment = CENTER.
       * </pre>
       */
      public Builder setTrayToLensDistance(float value) {
        bitField0_ |= 0x00000040;
        trayToLensDistance_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional float tray_to_lens_distance = 6;</code>
       *
       * <pre>
       * If the phone is aligned vertically within the device by resting against
       * a fixed top or bottom tray, this is the distance from the tray to
       * optical center of the lenses.
       * NOTE: Due to a bug in initial versions of the SDK's, this field
       * must be set explicitly to .035 when vertical_alignment = CENTER.
       * </pre>
       */
      public Builder clearTrayToLensDistance() {
        bitField0_ = (bitField0_ & ~0x00000040);
        trayToLensDistance_ = 0F;
        onChanged();
        return this;
      }

      private java.util.List<java.lang.Float> distortionCoefficients_ = java.util.Collections.emptyList();
      private void ensureDistortionCoefficientsIsMutable() {
        if (!((bitField0_ & 0x00000080) == 0x00000080)) {
          distortionCoefficients_ = new java.util.ArrayList<java.lang.Float>(distortionCoefficients_);
          bitField0_ |= 0x00000080;
         }
      }
      /**
       * <code>repeated float distortion_coefficients = 7 [packed = true];</code>
       *
       * <pre>
       * Coefficients Ki for pincushion distortion function which maps
       * from position on real screen to virtual screen (i.e. texture) relative
       * to optical center:
       *    p' = p (1 + K1 r^2 + K2 r^4 + ... + Kn r^(2n))
       * where r is the distance in tan-angle units from the optical center,
       * p the input point, and p' the output point.  Tan-angle units can be
       * computed as distance on the screen divided by distance from the
       * virtual eye to the screen.
       * </pre>
       */
      public java.util.List<java.lang.Float>
          getDistortionCoefficientsList() {
        return java.util.Collections.unmodifiableList(distortionCoefficients_);
      }
      /**
       * <code>repeated float distortion_coefficients = 7 [packed = true];</code>
       *
       * <pre>
       * Coefficients Ki for pincushion distortion function which maps
       * from position on real screen to virtual screen (i.e. texture) relative
       * to optical center:
       *    p' = p (1 + K1 r^2 + K2 r^4 + ... + Kn r^(2n))
       * where r is the distance in tan-angle units from the optical center,
       * p the input point, and p' the output point.  Tan-angle units can be
       * computed as distance on the screen divided by distance from the
       * virtual eye to the screen.
       * </pre>
       */
      public int getDistortionCoefficientsCount() {
        return distortionCoefficients_.size();
      }
      /**
       * <code>repeated float distortion_coefficients = 7 [packed = true];</code>
       *
       * <pre>
       * Coefficients Ki for pincushion distortion function which maps
       * from position on real screen to virtual screen (i.e. texture) relative
       * to optical center:
       *    p' = p (1 + K1 r^2 + K2 r^4 + ... + Kn r^(2n))
       * where r is the distance in tan-angle units from the optical center,
       * p the input point, and p' the output point.  Tan-angle units can be
       * computed as distance on the screen divided by distance from the
       * virtual eye to the screen.
       * </pre>
       */
      public float getDistortionCoefficients(int index) {
        return distortionCoefficients_.get(index);
      }
      /**
       * <code>repeated float distortion_coefficients = 7 [packed = true];</code>
       *
       * <pre>
       * Coefficients Ki for pincushion distortion function which maps
       * from position on real screen to virtual screen (i.e. texture) relative
       * to optical center:
       *    p' = p (1 + K1 r^2 + K2 r^4 + ... + Kn r^(2n))
       * where r is the distance in tan-angle units from the optical center,
       * p the input point, and p' the output point.  Tan-angle units can be
       * computed as distance on the screen divided by distance from the
       * virtual eye to the screen.
       * </pre>
       */
      public Builder setDistortionCoefficients(
          int index, float value) {
        ensureDistortionCoefficientsIsMutable();
        distortionCoefficients_.set(index, value);
        onChanged();
        return this;
      }
      /**
       * <code>repeated float distortion_coefficients = 7 [packed = true];</code>
       *
       * <pre>
       * Coefficients Ki for pincushion distortion function which maps
       * from position on real screen to virtual screen (i.e. texture) relative
       * to optical center:
       *    p' = p (1 + K1 r^2 + K2 r^4 + ... + Kn r^(2n))
       * where r is the distance in tan-angle units from the optical center,
       * p the input point, and p' the output point.  Tan-angle units can be
       * computed as distance on the screen divided by distance from the
       * virtual eye to the screen.
       * </pre>
       */
      public Builder addDistortionCoefficients(float value) {
        ensureDistortionCoefficientsIsMutable();
        distortionCoefficients_.add(value);
        onChanged();
        return this;
      }
      /**
       * <code>repeated float distortion_coefficients = 7 [packed = true];</code>
       *
       * <pre>
       * Coefficients Ki for pincushion distortion function which maps
       * from position on real screen to virtual screen (i.e. texture) relative
       * to optical center:
       *    p' = p (1 + K1 r^2 + K2 r^4 + ... + Kn r^(2n))
       * where r is the distance in tan-angle units from the optical center,
       * p the input point, and p' the output point.  Tan-angle units can be
       * computed as distance on the screen divided by distance from the
       * virtual eye to the screen.
       * </pre>
       */
      public Builder addAllDistortionCoefficients(
          java.lang.Iterable<? extends java.lang.Float> values) {
        ensureDistortionCoefficientsIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, distortionCoefficients_);
        onChanged();
        return this;
      }
      /**
       * <code>repeated float distortion_coefficients = 7 [packed = true];</code>
       *
       * <pre>
       * Coefficients Ki for pincushion distortion function which maps
       * from position on real screen to virtual screen (i.e. texture) relative
       * to optical center:
       *    p' = p (1 + K1 r^2 + K2 r^4 + ... + Kn r^(2n))
       * where r is the distance in tan-angle units from the optical center,
       * p the input point, and p' the output point.  Tan-angle units can be
       * computed as distance on the screen divided by distance from the
       * virtual eye to the screen.
       * </pre>
       */
      public Builder clearDistortionCoefficients() {
        distortionCoefficients_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000080);
        onChanged();
        return this;
      }

      private boolean hasMagnet_ ;
      /**
       * <code>optional bool has_magnet = 10;</code>
       *
       * <pre>
       * Optionally, whether the head mount uses a magnet in any part of its
       * design.  Intended as hint as to whether phone's magnetometer is
       * available for tasks such as orientation tracking.
       * </pre>
       */
      public boolean hasHasMagnet() {
        return ((bitField0_ & 0x00000100) == 0x00000100);
      }
      /**
       * <code>optional bool has_magnet = 10;</code>
       *
       * <pre>
       * Optionally, whether the head mount uses a magnet in any part of its
       * design.  Intended as hint as to whether phone's magnetometer is
       * available for tasks such as orientation tracking.
       * </pre>
       */
      public boolean getHasMagnet() {
        return hasMagnet_;
      }
      /**
       * <code>optional bool has_magnet = 10;</code>
       *
       * <pre>
       * Optionally, whether the head mount uses a magnet in any part of its
       * design.  Intended as hint as to whether phone's magnetometer is
       * available for tasks such as orientation tracking.
       * </pre>
       */
      public Builder setHasMagnet(boolean value) {
        bitField0_ |= 0x00000100;
        hasMagnet_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional bool has_magnet = 10;</code>
       *
       * <pre>
       * Optionally, whether the head mount uses a magnet in any part of its
       * design.  Intended as hint as to whether phone's magnetometer is
       * available for tasks such as orientation tracking.
       * </pre>
       */
      public Builder clearHasMagnet() {
        bitField0_ = (bitField0_ & ~0x00000100);
        hasMagnet_ = false;
        onChanged();
        return this;
      }

      private int primaryButton_ = 1;
      /**
       * <code>optional .DeviceParams.ButtonType primary_button = 12 [default = MAGNET];</code>
       *
       * <pre>
       * Specify primary input mechanism of the HMD.  Intended for advisory
       * purposes only, to address simple questions such as "can HMD
       * be used with apps requiring a physical button event?" or "what icon
       * should be used to represent button action to the user?".
       * </pre>
       */
      public boolean hasPrimaryButton() {
        return ((bitField0_ & 0x00000200) == 0x00000200);
      }
      /**
       * <code>optional .DeviceParams.ButtonType primary_button = 12 [default = MAGNET];</code>
       *
       * <pre>
       * Specify primary input mechanism of the HMD.  Intended for advisory
       * purposes only, to address simple questions such as "can HMD
       * be used with apps requiring a physical button event?" or "what icon
       * should be used to represent button action to the user?".
       * </pre>
       */
      public CardboardDevice.DeviceParams.ButtonType getPrimaryButton() {
        CardboardDevice.DeviceParams.ButtonType result = CardboardDevice.DeviceParams.ButtonType.valueOf(primaryButton_);
        return result == null ? CardboardDevice.DeviceParams.ButtonType.MAGNET : result;
      }
      /**
       * <code>optional .DeviceParams.ButtonType primary_button = 12 [default = MAGNET];</code>
       *
       * <pre>
       * Specify primary input mechanism of the HMD.  Intended for advisory
       * purposes only, to address simple questions such as "can HMD
       * be used with apps requiring a physical button event?" or "what icon
       * should be used to represent button action to the user?".
       * </pre>
       */
      public Builder setPrimaryButton(CardboardDevice.DeviceParams.ButtonType value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000200;
        primaryButton_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <code>optional .DeviceParams.ButtonType primary_button = 12 [default = MAGNET];</code>
       *
       * <pre>
       * Specify primary input mechanism of the HMD.  Intended for advisory
       * purposes only, to address simple questions such as "can HMD
       * be used with apps requiring a physical button event?" or "what icon
       * should be used to represent button action to the user?".
       * </pre>
       */
      public Builder clearPrimaryButton() {
        bitField0_ = (bitField0_ & ~0x00000200);
        primaryButton_ = 1;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:DeviceParams)
    }

    // @@protoc_insertion_point(class_scope:DeviceParams)
    private static final CardboardDevice.DeviceParams DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new CardboardDevice.DeviceParams();
    }

    public static CardboardDevice.DeviceParams getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<DeviceParams>
        PARSER = new com.google.protobuf.AbstractParser<DeviceParams>() {
      public DeviceParams parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        try {
          return new DeviceParams(input, extensionRegistry);
        } catch (RuntimeException e) {
          if (e.getCause() instanceof
              com.google.protobuf.InvalidProtocolBufferException) {
            throw (com.google.protobuf.InvalidProtocolBufferException)
                e.getCause();
          }
          throw e;
        }
      }
    };

    public static com.google.protobuf.Parser<DeviceParams> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<DeviceParams> getParserForType() {
      return PARSER;
    }

    public CardboardDevice.DeviceParams getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  private static com.google.protobuf.Descriptors.Descriptor
    internal_static_DeviceParams_descriptor;
  private static
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_DeviceParams_fieldAccessorTable;

  public static com.google.protobuf.Descriptors.FileDescriptor
      getDescriptor() {
    return descriptor;
  }
  private static com.google.protobuf.Descriptors.FileDescriptor
      descriptor;
  static {
    java.lang.String[] descriptorData = {
      "\n\025CardboardDevice.proto\"\356\003\n\014DeviceParams" +
      "\022\016\n\006vendor\030\001 \001(\t\022\r\n\005model\030\002 \001(\t\022\037\n\027scree" +
      "n_to_lens_distance\030\003 \001(\002\022\033\n\023inter_lens_d" +
      "istance\030\004 \001(\002\022)\n\035left_eye_field_of_view_" +
      "angles\030\005 \003(\002B\002\020\001\022G\n\022vertical_alignment\030\013" +
      " \001(\0162#.DeviceParams.VerticalAlignmentTyp" +
      "e:\006BOTTOM\022\035\n\025tray_to_lens_distance\030\006 \001(\002" +
      "\022#\n\027distortion_coefficients\030\007 \003(\002B\002\020\001\022\022\n" +
      "\nhas_magnet\030\n \001(\010\0228\n\016primary_button\030\014 \001(" +
      "\0162\030.DeviceParams.ButtonType:\006MAGNET\"8\n\025V",
      "erticalAlignmentType\022\n\n\006BOTTOM\020\000\022\n\n\006CENT" +
      "ER\020\001\022\007\n\003TOP\020\002\"A\n\nButtonType\022\010\n\004NONE\020\000\022\n\n" +
      "\006MAGNET\020\001\022\t\n\005TOUCH\020\002\022\022\n\016INDIRECT_TOUCH\020\003"
    };
    com.google.protobuf.Descriptors.FileDescriptor.InternalDescriptorAssigner assigner =
        new com.google.protobuf.Descriptors.FileDescriptor.    InternalDescriptorAssigner() {
          public com.google.protobuf.ExtensionRegistry assignDescriptors(
              com.google.protobuf.Descriptors.FileDescriptor root) {
            descriptor = root;
            return null;
          }
        };
    com.google.protobuf.Descriptors.FileDescriptor
      .internalBuildGeneratedFileFrom(descriptorData,
        new com.google.protobuf.Descriptors.FileDescriptor[] {
        }, assigner);
    internal_static_DeviceParams_descriptor =
      getDescriptor().getMessageTypes().get(0);
    internal_static_DeviceParams_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_DeviceParams_descriptor,
        new java.lang.String[] { "Vendor", "Model", "ScreenToLensDistance", "InterLensDistance", "LeftEyeFieldOfViewAngles", "VerticalAlignment", "TrayToLensDistance", "DistortionCoefficients", "HasMagnet", "PrimaryButton", });
  }

  // @@protoc_insertion_point(outer_class_scope)
}
